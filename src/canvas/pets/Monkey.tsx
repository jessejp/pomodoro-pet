/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import { useRef, Suspense } from "react";
import { useGLTF } from "@react-three/drei";
import * as THREE from "three";
import { TextureLoader } from "three/src/loaders/TextureLoader.js";
import { GLTF } from "three-stdlib";
import { useLoader } from "@react-three/fiber";
import useAnimPhases from "../../utils/useAnimPhases";
import HeadSlot from "../cosmetics/HeadSlot";
import { useBoundStore } from "../../store/useBoundStore";

type ActionName =
  | "continue_study"
  | "none"
  | "page_flip"
  | "page_none"
  | "pause"
  | "start_break"
  | "start_study"
  | "study"
  | "study_v2";
// type GLTFActions = Record<ActionName, THREE.AnimationAction>;

export interface PetGLTFAction extends THREE.AnimationClip {
  name: ActionName;
}

type GLTFResult = GLTF & {
  nodes: {
    monkey: THREE.SkinnedMesh;
    root: THREE.Bone;
    ["MCH-torsoparent"]: THREE.Bone;
    ["MCH-hand_ikparentL"]: THREE.Bone;
    ["MCH-upper_arm_ik_targetparentL"]: THREE.Bone;
    ["MCH-hand_ikparentR"]: THREE.Bone;
    ["MCH-upper_arm_ik_targetparentR"]: THREE.Bone;
    ["MCH-foot_ikparentL"]: THREE.Bone;
    ["MCH-thigh_ik_targetparentL"]: THREE.Bone;
    ["MCH-foot_ikparentR"]: THREE.Bone;
    ["MCH-thigh_ik_targetparentR"]: THREE.Bone;
  };
  animations: PetGLTFAction[];
};

const filePath = "/models/pomodoro_pets_monkey_1_v2.glb";

const material = new THREE.MeshBasicMaterial();

export default function Monkey(props: JSX.IntrinsicElements["group"]) {
  const { equippedCosmetic, modelLoaded } = useBoundStore((state) => ({
    equippedCosmetic: state.equippedCosmetic,
    modelLoaded: state.modelLoaded,
  }));

  const group = useRef<THREE.Group>(null);
  const { nodes, animations } = useGLTF(filePath, true, undefined, (loader) => {
    loader.manager.onLoad = () => {
      modelLoaded();
    };
  }) as GLTFResult;

  useAnimPhases({ animations: animations, groupRef: group, isPet: true });

  const texture = useLoader(TextureLoader, "textures/monkey_1_diffuse.png");
  texture.flipY = false;
  texture.minFilter = THREE.NearestFilter;
  texture.magFilter = THREE.NearestFilter;

  const headSlotItem = equippedCosmetic.cosmetics.find(
    (cosmetic) => cosmetic.slot === "head"
  );

  return (
    <group ref={group} {...props} dispose={null}>
      <group name="Scene">
        <group name="monkey_rig">
          <skinnedMesh
            name="monkey"
            geometry={nodes.monkey.geometry}
            material={material}
            material-map={texture}
            skeleton={nodes.monkey.skeleton}
          />
          {!!headSlotItem && (
            <Suspense fallback={null}>
              <HeadSlot
                name={headSlotItem.name}
                skeleton={nodes.monkey.skeleton}
              />
            </Suspense>
          )}
          <primitive object={nodes.root} />
          <primitive object={nodes["MCH-torsoparent"]} />
          <primitive object={nodes["MCH-hand_ikparentL"]} />
          <primitive object={nodes["MCH-upper_arm_ik_targetparentL"]} />
          <primitive object={nodes["MCH-hand_ikparentR"]} />
          <primitive object={nodes["MCH-upper_arm_ik_targetparentR"]} />
          <primitive object={nodes["MCH-foot_ikparentL"]} />
          <primitive object={nodes["MCH-thigh_ik_targetparentL"]} />
          <primitive object={nodes["MCH-foot_ikparentR"]} />
          <primitive object={nodes["MCH-thigh_ik_targetparentR"]} />
        </group>
      </group>
    </group>
  );
}
