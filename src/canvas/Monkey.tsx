/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import { useEffect, useRef } from "react";
import { useGLTF, useAnimations } from "@react-three/drei";
import { usePomodoro } from "../utils/usePomodoro";
import * as THREE from "three";
import { TextureLoader } from "three/src/loaders/TextureLoader.js";
import { GLTF } from "three-stdlib";
import { useLoader } from "@react-three/fiber";

type ActionName =
  | "All Animations"
  | "break"
  | "continue_study"
  | "none"
  | "start_break"
  | "start_study"
  | "study";
// type GLTFActions = Record<ActionName, THREE.AnimationAction>;

interface GLTFAction extends THREE.AnimationClip {
  name: ActionName;
}

type GLTFResult = GLTF & {
  nodes: {
    MonkeyMesh: THREE.SkinnedMesh;
    RL_BoneRoot: THREE.Bone;
  };
  animations: GLTFAction[];
};

const filePath = "/models/monkey_pet_v02.glb";

const material = new THREE.MeshBasicMaterial();


export default function Monkey(props: JSX.IntrinsicElements["group"]) {
  const { pomodoroPhase, currentRound } = usePomodoro();
  const group = useRef<THREE.Group>(null);
  const { nodes, animations } = useGLTF(filePath) as GLTFResult;
  const { actions } = useAnimations(animations, group);

  const texture = useLoader(TextureLoader, "textures/monkeyTexture.png");
  texture.flipY = false;
  texture.minFilter = THREE.NearestFilter;
  texture.magFilter = THREE.NearestFilter;

  useEffect(() => {
    if (pomodoroPhase === "none") {
      actions.none?.reset().fadeIn(0.5).play();
      return () => actions.none?.fadeOut(0.5);
    } else if (pomodoroPhase === "work" && currentRound === 0) {
      actions.start_study
        ?.reset()
        .fadeIn(0.5)
        .setLoop(THREE.LoopOnce, 0)
        .play();

      if (actions.start_study && !actions.start_study?.clampWhenFinished)
        actions.start_study.clampWhenFinished = true;

      const delayedAction = setTimeout(() => {
        actions.study?.reset().fadeIn(0).play();
      }, 4000);

      return () => {
        actions.start_study?.fadeOut(0.5);
        actions.study?.fadeOut(0.5);
        clearTimeout(delayedAction);
      };
    } else if (pomodoroPhase === "break") {
      actions.start_break
        ?.reset()
        .fadeIn(0.5)
        .setLoop(THREE.LoopOnce, 0)
        .play();

      if (actions.start_break && !actions.start_break?.clampWhenFinished)
        actions.start_break.clampWhenFinished = true;

      const delayedAction = setTimeout(() => {
        actions.break?.reset().fadeIn(0).play();
      }, 4000);

      return () => {
        actions.start_break?.fadeOut(0.5);
        actions.break?.fadeOut(0.5);
        clearTimeout(delayedAction);
      };
    } else if (pomodoroPhase === "work" && currentRound > 0) {
      actions.continue_study
        ?.reset()
        .fadeIn(0.5)
        .setLoop(THREE.LoopOnce, 0)
        .play();

      if (actions.continue_study && !actions.continue_study?.clampWhenFinished)
        actions.continue_study.clampWhenFinished = true;

      const delayedAction = setTimeout(() => {
        actions.study?.reset().fadeIn(0).play();
      }, 4000);

      return () => {
        actions.continue_study?.fadeOut(0.5);
        actions.study?.fadeOut(0.5);
        clearTimeout(delayedAction);
      };
    }
  }, [pomodoroPhase, currentRound, actions]);

  return (
    <group ref={group} {...props} dispose={null}>
      <group name="Scene">
        <group name="Armature" scale={0.002}>
          <skinnedMesh
            name="MonkeyMesh"
            geometry={nodes.MonkeyMesh.geometry}
            material={material}
            material-map={texture}
            skeleton={nodes.MonkeyMesh.skeleton}
          />
          <primitive object={nodes.RL_BoneRoot} />
        </group>
      </group>
    </group>
  );
}

useGLTF.preload(filePath);
