generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id               String            @id @default(cuid())
  name             String?
  isPublic         Boolean           @default(false) @map("is_public")
  pomodoroSessions PomodoroSession[]
  tasks            Task[]
  authSessions     AuthSession[]
  accounts         Account[]


  @@map("users")
}

model Account {
  id                String  @id @default(cuid())
  userId            String  @map("user_id")
  type              String // e.g., "oauth", "credentials", "email"
  provider          String // e.g., "google", "github"
  providerAccountId String  @map("provider_account_id") // The user's ID from the OAuth provider
  refreshToken      String? @map("refresh_token") @db.Text // Optional: store refresh token
  accessToken       String? @map("access_token") @db.Text // Optional: store access token
  expiresAt         Int?    @map("expires_at")
  tokenType         String? @map("token_type")
  scope             String?
  idToken           String? @map("id_token") @db.Text
  sessionState      String? @map("session_state")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade) // If user is deleted, delete their accounts

  @@unique([provider, providerAccountId]) // Ensures a user can only link an OAuth account once

  @@map("accounts")
}

model AuthSession {
  id           String   @id @default(cuid())
  sessionToken String   @unique @map("session_token") // The actual token used to verify the user's login
  expires      DateTime
  userId       String   @map("user_id")
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("auth_session")
}

model PomodoroSession {
  id                     String                   @id @default(cuid())
  startDate              DateTime                 @default(now()) @map("start_date")
  endDate                DateTime                 @default(now()) @map("end_date")
  stopDate               DateTime                 @default(now()) @map("stop_date")
  workTimeMinutes        Int                      @default(25) @map("work_time_minutes")
  breakTimeMinutes       Int                      @default(5) @map("break_time_minutes")
  rounds                 Int                      @default(4)
  tasks                  Task[]
  userId                 String                   @map("user_id")
  user                   User                     @relation(fields: [userId], references: [id])
  TasksOnPomodoroSession TasksOnPomodoroSession[]

  @@index([startDate], name: "idx_pomodoro_session_start_date") // Index for faster queries by start date
  @@map("pomodoro_session")
}

model Task {
  id                     String                   @id @default(cuid())
  name                   String
  isDone                 Boolean                  @default(false) @map("is_done")
  totalCompletedSeconds  Int                      @default(0) @map("total_completed_seconds")
  pomodoroSessions       PomodoroSession[]
  userId                 String                   @map("user_id")
  user                   User                     @relation(fields: [userId], references: [id])
  TasksOnPomodoroSession TasksOnPomodoroSession[]

  @@map("tasks")
}

model TasksOnPomodoroSession {
  id                String          @id @default(cuid())
  pomodoroSessionId String          @map("pomodoro_session_id")
  taskId            String          @map("task_id")
  pomodoroSession   PomodoroSession @relation(fields: [pomodoroSessionId], references: [id], onDelete: Cascade)
  task              Task            @relation(fields: [taskId], references: [id], onDelete: Cascade)

  @@unique([pomodoroSessionId, taskId]) // Ensures a task can only be linked to a pomodoro session once
  @@map("tasks_on_pomodoro_session")
}
